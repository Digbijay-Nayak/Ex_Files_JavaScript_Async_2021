### Defining asynchronous programming

- We can build program flow in JavaScript in two different ways. Synchronously and asynchronously. Using synchronous program flow, code is executed in the order it appears in your JavaScript files. So here, lines one through five of the code are executed first followed by lines six through 10 and then lines 11 through 15 are executed next, matching the order of statements in the code as written.
- In synchronous program flow, the browser parses and executes only one statement at a time. This results in our statements being executed in order. Synchronous program flow exhibits a behavior known as blocking, meaning that later statements are prevented from executing until earlier statements are finished. In many cases, this is what we want.
- For instance, a value needs to be calculated first before it can be used. But if an earlier statement may take awhile to execute and statements that follow don't rely on that earlier statement having finished, then synchronous program flow can needlessly slow down our apps. In this case, we want to use asynchronous program flow.
- When we write this type of code, also known as asynchronous code or simply async, the parser can start executing some code and continue that execution while other code is executed as well. So here, lines one through five of the code start execution, but these include some activity that's going to take awhile.
- Now technically JavaScript has only a single thread, but it does have a mechanism that allows some processes to execute in parallel while other things are going on. So here, this first set of statements is moved into that parallel process, which continues executing even as the main program flow moves to the next set of statements. Now that main program flow continues synchronous execution, so it keeps moving through the remaining code while that first block of code is executing in parallel.
- Now remember that synchronous code is executed only in the main program flow, while we've seen that asynchronous code is instead moved over to execute in parallel. This means that the statements are executed simultaneously. The upshot of this architecture is that asynchronous program flow lets us write code that's non-blocking.
- We write asynchronous code when we want to give part of our code time to complete while still allowing the parsers to continue executing the code that follows right away. One of the most common situations where we use asynchronous program flow is when we make Ajax requests. We write code using XHR or fetch, or maybe a library specific method that sends a request for data to a remote server. This code defaults to an asynchronous mode, meaning that the request gets sent off, and while the parser is waiting for a response, the main program flow moves on to execute other code, like responding to user interactions. Another common situation where asynchronous flow is useful is setting a timer using something like set timeout. The timer starts, and while it's counting down, the main program flow can go on to execute other code.

- https://github.com/taylorhakes/promise-polyfill
- https://babeljs.io/

### What is a web worker?

- JavaScript includes a number of features that enable you to program asynchronously, including callbacks, promises and async/await, but all of these async processes still rely on the main browser thread to execute their code after any delay has taken place, such as a set timeout or a response to an AJAX request.
- The traditional asynchronous model for JavaScript simply rearranges the order in which code is executed on a single thread to avoid blocking, but features that use this model remain limited by the fact, that with a single thread, the browser can do only one thing at a time.
- Modern browsers support some newer additions to JavaScript that make use of additional threads. One of these newer additions is web workers. A web worker enables you to specify code that will be executed in its own thread on the processor separate from the browser thread.
- This enables you to make your code asynchronous and also allows your app to do multiple things at once by leveraging one or more additional processor threads. With a web worker, your app sends a message to the code running in the additional thread. This code does the requested work on its thread, then responds with its own message, which often contains data that's then used in your app. Web workers are most useful in an app that needs to do complex processing, such as involved mathematical operations. Sending a task like this to a web worker frees up the browser thread so your user interface remains responsive.
